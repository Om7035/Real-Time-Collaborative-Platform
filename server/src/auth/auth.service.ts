import { User, RegisterRequest, LoginRequest, AuthTokens } from '../types/auth.types';
import { PasswordUtil } from './password.util';
import { JWTUtil } from './jwt.util';
import { isValidEmail } from '../utils/helpers';
import logger from '../utils/logger';
import { UserModel } from '../db/models/user.model';

export class AuthService {

    async initialize(): Promise<void> {
        // No-op for Mongoose (connection handled in server.ts)
        logger.info('AuthService initialized');
    }

    async register(request: RegisterRequest): Promise<AuthTokens> {
        const { email, password } = request;

        if (!isValidEmail(email)) {
            throw new Error('Invalid email format');
        }

        const existingUser = await UserModel.findOne({ email });
        if (existingUser) {
            throw new Error('Email already registered');
        }

        const passwordValidation = PasswordUtil.validate(password);
        if (!passwordValidation.valid) {
            throw new Error(passwordValidation.errors.join(', '));
        }

        const passwordHash = await PasswordUtil.hash(password);

        const newUser = new UserModel({
            // _id will be auto-generated by Mongo, but we can also set custom ID if strict
            // But better to let Mongo handle ID and just map it.
            // Wait, existing system expects 'id' as string. Mongoose produces ObjectId.
            // Our Schema transform handles this.
            email,
            passwordHash,
            role: 'user',
            createdAt: Date.now(),
        });

        await newUser.save();
        const user = newUser.toJSON() as unknown as User;

        logger.info('User registered', { userId: user.id, email });

        return JWTUtil.generateTokens({
            userId: user.id,
            email: user.email,
            role: user.role,
        });
    }

    async login(request: LoginRequest): Promise<AuthTokens> {
        const { email, password } = request;

        const userDoc = await UserModel.findOne({ email });
        if (!userDoc) {
            throw new Error('Invalid credentials');
        }

        const isPasswordValid = await PasswordUtil.compare(password, userDoc.passwordHash);
        if (!isPasswordValid) {
            throw new Error('Invalid credentials');
        }

        const user = userDoc.toJSON() as unknown as User;

        logger.info('User logged in', { userId: user.id, email });

        return JWTUtil.generateTokens({
            userId: user.id,
            email: user.email,
            role: user.role,
        });
    }

    async refreshToken(refreshToken: string): Promise<AuthTokens> {
        const payload = JWTUtil.verifyRefreshToken(refreshToken);

        const userDoc = await UserModel.findById(payload.userId);
        if (!userDoc) {
            throw new Error('User not found');
        }

        const user = userDoc.toJSON() as unknown as User;

        return JWTUtil.generateTokens({
            userId: user.id,
            email: user.email,
            role: user.role,
        });
    }

    async getUserById(userId: string): Promise<User | null> {
        const doc = await UserModel.findById(userId);
        return doc ? (doc.toJSON() as unknown as User) : null;
    }

    async findUserByEmail(email: string): Promise<User | null> {
        const doc = await UserModel.findOne({ email });
        return doc ? (doc.toJSON() as unknown as User) : null;
    }

    validateAccessToken(token: string): boolean {
        try {
            JWTUtil.verifyAccessToken(token);
            return true;
        } catch {
            return false;
        }
    }
}

export const authService = new AuthService();
